# 1. プロセスをライブラリ的に使う
# 例えば、 GenServer behaviour を実装した Calculator プロセスがあり、add, subtract, ... などのメッセージがあるとする
# これを複数プロセスから通信して計算を行うと、ボトルネックになってパフォーマンスが下がる

# 2. プロセスインターフェースを分散させる
# ある Agent プロセスの状態操作を A, B, C, D のモジュールが行うとする。
# これはバグを生みやすい。

# 3. 不要なメッセージを送る or でかいすぎるメッセージを送る
# Erlang のアーキテクチャにより、全てのプロセスは何も共有せずそれぞれがメモリを持っている
# send でメッセージを送ると、そのデータは送信先/元でそれぞれのメモリに複製される。でかいデータを送るとメモリの無駄な使用につながる
#
# 例. HTTP リクエストの conn 構造体 (ボディ、ヘッダー、その他情報など、大きなデータで構成される)
# これは、コールバックとして無名関数を渡す場合にも、関数内に値がキャプチャ(= コピー)されるので注意
#
# 解決策: 必要なデータだけ送る、送信先プロセスだけがデータを必要とするならプロセスにデータを取得させる(fetchさせるとか)、 :persistent_term でプロセス間でデータ共有する

# 4. Supervision なしのプロセス
# 監視ツリー外にプロセスを作成すること自体はアンチパターンではない
# ただ、監視ツリー外で"長時間"実行されるプロセスを"大量に"作成すると、アプリケーションが制御不可能になる

# 例. GenServer を実装したモジュールの、 {ProcessMod}.start_link/1 をコード内で何度も呼び出す
# iex> {:ok, pid1} = Counter.start_link()
# iex> {:ok, pid2} = Counter.start_link(initial_value: 15, name: :other_counter)
# iex> Counter.get()
# iex> Counter.get(:other_counter)
defmodule ProcessAntiPattern do
end
